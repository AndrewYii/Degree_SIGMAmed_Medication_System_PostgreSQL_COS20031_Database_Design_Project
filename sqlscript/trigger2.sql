-- FUNCTION: Auto-create role-specific entry when User is inserted
CREATE OR REPLACE FUNCTION "SIGMAmed".auto_create_role_entry()
RETURNS TRIGGER AS $$
BEGIN
    -- Create corresponding role table entry based on user role
    IF NEW."Role" = 'doctor' THEN
        -- Insert placeholder doctor record (will need to be updated later)
        INSERT INTO "SIGMAmed"."Doctor" (
            "UserId",
            "MedicalLicenseNumber",
            "Specialization",
            "YearOfExperience"
        ) VALUES (
            NEW."UserId",
            'TEMP-' || NEW."UserId",  -- Temporary license number
            'General Practice',        -- Default specialization
            0                    -- Default experience
        );
        
        RAISE NOTICE 'Doctor record created for User %. Please update MedicalLicenseNumber, Specialization, and other details.', NEW."UserId";
        
    ELSIF NEW."Role" = 'patient' THEN
        -- PatientNumber will be auto-generated by trigger_generate_patient_number
        -- Leave PatientNumber empty/null, the BEFORE INSERT trigger on Patient will set it
        INSERT INTO "SIGMAmed"."Patient" (
            "UserId",
            "PatientNumber",
            "BloodType",
            "HeightCm",
            "WeightKg",
            "EmergencyContactName",
            "EmergencyContactNumber",
            "MedicationAllergies"
        ) VALUES (
            NEW."UserId",
            '',  -- Will be set by trigger_generate_patient_number
            NULL,
            0,
            0,
            ' ',
            ' ',
            '[]'::JSONB
        );
        
        RAISE NOTICE 'Patient record created for User %. Patient number will be auto-generated.', NEW."UserId";
        
    ELSIF NEW."Role" = 'admin' THEN
        INSERT INTO "SIGMAmed"."Admin" (
            "UserId",
            "AdminLevel"
        ) VALUES (
            NEW."UserId",
            'hospital'  -- Default to hospital admin level
        );
        
        RAISE NOTICE 'Admin record created for User % with hospital level access.', NEW."UserId";
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION "SIGMAmed".auto_create_role_entry IS 'Automatically create Doctor/Patient/Admin entry when User is created';

-- TRIGGER: Auto-create role entry after user insertion
CREATE TRIGGER trigger_auto_create_role_entry
AFTER INSERT ON "SIGMAmed"."User"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".auto_create_role_entry();

-- TRIGGER: Auto-generate Patient Number
CREATE OR REPLACE FUNCTION "SIGMAmed".generate_patient_number()
RETURNS TRIGGER AS $$
DECLARE
    v_year TEXT;
    v_patient_number TEXT;
    v_counter INT;
BEGIN
    -- Generate patient number if it's NULL or empty string
    IF NEW."PatientNumber" IS NULL OR NEW."PatientNumber" = '' THEN
        v_year := TO_CHAR(CURRENT_DATE, 'YYYY');
        
        -- Get next sequence using pg_advisory_xact_lock for thread safety during bulk inserts
        PERFORM pg_advisory_xact_lock(hashtext('patient_number_seq_' || v_year));
        
        -- Get the maximum sequence number for this year
        SELECT COALESCE(MAX(
            CAST(SUBSTRING("PatientNumber" FROM 10 FOR 6) AS INT)
        ), 0) + 1
        INTO v_counter
        FROM "SIGMAmed"."Patient"
        WHERE "PatientNumber" ~ ('^PAT-' || v_year || '-[0-9]{6}$');
        
        v_patient_number := 'PAT-' || v_year || '-' || LPAD(v_counter::TEXT, 6, '0');
        NEW."PatientNumber" := v_patient_number;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION "SIGMAmed".generate_patient_number IS 'Automatically generate the patient number of patients.';
-- TRIGGER: Auto-generate Patient Number
CREATE TRIGGER trigger_generate_patient_number
BEFORE INSERT ON "SIGMAmed"."Patient"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".generate_patient_number();

-- TRIGGER: Prevent deleting active prescriptions
CREATE OR REPLACE FUNCTION "SIGMAmed".prevent_delete_active_prescription()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD."Status" = 'active' AND NEW."IsDeleted" = TRUE THEN
        RAISE EXCEPTION 'Cannot delete active prescription. Please complete or cancel first.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION "SIGMAmed".prevent_delete_active_prescription IS 'Prevent deleting the active prescriptions.';

-- TRIGGER: Prevent deleting active prescriptions
CREATE TRIGGER trigger_prevent_delete_active_prescription
BEFORE UPDATE OF "IsDeleted" ON "SIGMAmed"."Prescription"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".prevent_delete_active_prescription();

-- TRIGGER: Prevent past appointment creation (less the create trigger)
CREATE OR REPLACE FUNCTION "SIGMAmed".prevent_past_appointments()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW."AppointmentDate" < CURRENT_DATE THEN
        RAISE EXCEPTION 'Cannot create appointment in the past';
    END IF;
    
    IF NEW."AppointmentDate" = CURRENT_DATE THEN
        RAISE EXCEPTION 'Cannot create appointment in the past';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION "SIGMAmed".prevent_past_appointments IS 'Prevent past appointment creation.';

-- TRIGGER: Prevent past appointments
CREATE TRIGGER trigger_prevent_past_appointments
BEFORE INSERT ON "SIGMAmed"."Appointment"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".prevent_past_appointments();

-- FUNCTION: Notify doctor when new patient reports comes in
CREATE OR REPLACE FUNCTION "SIGMAmed".notify_extract_keyword()
RETURNS TRIGGER AS $$
BEGIN
    -- Only notify if Description is not null and Keywords still null
    IF NEW."Description" IS NOT NULL AND NEW."Keywords" IS NULL THEN
        PERFORM pg_notify('report_ready_for_processing', NEW."PatientReportId"::text);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION "SIGMAmed".notify_extract_keyword IS 'Notify doctor when new patient reports comes in.';

CREATE TRIGGER patient_report_update_trigger
AFTER UPDATE OF "Description" ON "SIGMAmed"."PatientReport"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".notify_extract_keyword();

-- FUNCTION: Auto create the prescribed medication schedule record in Prescribed Medication schedule
CREATE OR REPLACE FUNCTION "SIGMAmed".fn_generate_medication_schedule()
RETURNS TRIGGER AS $$
DECLARE
    interval_value INTERVAL;
    times_per_day INT;
    i INT;
    base_time TIME := TIME '08:00:00';
    next_time TIME;
BEGIN
    interval_value := NEW."DoseInterval";
    times_per_day := NEW."TimesPerDay";

    next_time := base_time;
    FOR i IN 1..times_per_day LOOP
        INSERT INTO "SIGMAmed"."PrescribedMedicationSchedule"(
            "PrescribedMedicationId",
            "ReminderTime",
            "DayOfWeekMask",
            "DoseSequenceId"
        )
        VALUES(
            NEW."PrescribedMedicationId",
            next_time,
            NEW."DefaultDayMask",
            i
        );
        next_time := (next_time + interval_value);
    END LOOP;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION "SIGMAmed".fn_generate_medication_schedule IS 'Auto create the prescribed medication schedule record in Prescribed Medication schedule.';

CREATE TRIGGER trg_after_prescribed_med_insert
AFTER INSERT ON "SIGMAmed"."PrescribedMedication"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".fn_generate_medication_schedule();

-- FUNCTION: Auto create the adherence record in Medication adherence 
CREATE OR REPLACE FUNCTION "SIGMAmed".fn_create_adherence_record()
RETURNS TRIGGER AS $$
DECLARE 
    prescribed_date DATE;
    expiry_date DATE;
    mask TEXT;
    day_index INT;
    check_date DATE;
    scheduled_timestamp TIMESTAMPTZ;
    v_prescription_id UUID;
BEGIN 
    -- Get prescribed_date + day mask + prescription id from PrescribedMedication
    SELECT 
        "PrescribedDate",
        "DefaultDayMask",
        "PrescriptionId"
    INTO 
        prescribed_date,
        mask,
        v_prescription_id
    FROM "SIGMAmed"."PrescribedMedication"
    WHERE "PrescribedMedicationId" = NEW."PrescribedMedicationId";

    -- Get expiry date from Prescription table
    SELECT "ExpiryDate"
    INTO expiry_date
    FROM "SIGMAmed"."Prescription"
    WHERE "PrescriptionId" = v_prescription_id;

    check_date := prescribed_date;

    -- DAILY LOOP UNTIL EXPIRY DATE
    WHILE check_date <= expiry_date LOOP
        
        day_index := EXTRACT(DOW FROM check_date)::INT;
        IF day_index = 0 THEN
            day_index := 7;
        END IF;

        -- If mask = '1' for this day, insert adherence record
        IF SUBSTRING(mask FROM day_index FOR 1) = '1' THEN
            scheduled_timestamp := check_date + NEW."ReminderTime";
            
            IF scheduled_timestamp > CURRENT_TIMESTAMP THEN
            INSERT INTO "SIGMAmed"."MedicationAdherenceRecord"(
                "PrescribedMedicationScheduleId",
                "DoseQuantity",
                "ScheduledTime"
            )
            VALUES(
                NEW."PrescribedMedicationScheduleId",
                NULL,
                scheduled_timestamp
            );
            END IF;
        END IF;

        check_date := check_date + INTERVAL '1 day';
    END LOOP;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION "SIGMAmed".fn_create_adherence_record IS 'Auto create the adherence record in Medication adherence.';


CREATE TRIGGER trg_after_insert_schedule
AFTER INSERT ON "SIGMAmed"."PrescribedMedicationSchedule"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".fn_create_adherence_record();


-- FUNCTION: Delete all old adherence
CREATE OR REPLACE FUNCTION "SIGMAmed".fn_delete_old_adherence()
RETURNS TRIGGER AS $$
BEGIN
    DELETE FROM "SIGMAmed"."MedicationAdherenceRecord"
    WHERE "PrescribedMedicationScheduleId" = OLD."PrescribedMedicationScheduleId" AND "CurrentStatus" = 'Pending' AND "ScheduledTime" > NOW();

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION "SIGMAmed".fn_create_adherence_record IS 'Delete all old adherence records in MedicationAdherenceRecordTable.';

CREATE TRIGGER trg_before_update_delete_adherence
BEFORE UPDATE ON "SIGMAmed"."PrescribedMedicationSchedule"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".fn_delete_old_adherence();


-- FUNCTION: Create the adherence record based on new day of week mask
CREATE OR REPLACE FUNCTION "SIGMAmed".fn_create_adherence_after_change()
RETURNS TRIGGER AS $$
DECLARE
    prescribed_date DATE;
    expiry_date DATE;
    day_index INT;
    check_date DATE;
    scheduled_timestamp TIMESTAMPTZ;
    prescription_id UUID;
    mask TEXT;
BEGIN
    -- Get schedule mask
    mask := NEW."DayOfWeekMask";

    -- Get prescription data
    SELECT 
        "PrescribedDate",
        "PrescriptionId"
    INTO
        prescribed_date,
        prescription_id
    FROM "SIGMAmed"."PrescribedMedication"
    WHERE "PrescribedMedicationId" = NEW."PrescribedMedicationId";

    -- Get expiry date
    SELECT "ExpiryDate"
    INTO expiry_date
    FROM "SIGMAmed"."Prescription"
    WHERE "PrescriptionId" = prescription_id;

    check_date := prescribed_date;

    -- Recreate adherence records
    WHILE check_date <= expiry_date LOOP
        day_index := EXTRACT(DOW FROM check_date);

        IF day_index = 0 THEN
            day_index := 7;
        END IF;

        IF SUBSTRING(mask FROM day_index FOR 1) = '1' THEN
            scheduled_timestamp := check_date + NEW."ReminderTime";

            INSERT INTO "SIGMAmed"."MedicationAdherenceRecord"(
                "PrescribedMedicationScheduleId",
                "DoseQuantity",
                "ScheduledTime"
            ) VALUES (
                NEW."PrescribedMedicationScheduleId",
                NULL,
                scheduled_timestamp
            );
        END IF;

        check_date := check_date + INTERVAL '1 day';
    END LOOP;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION "SIGMAmed".fn_create_adherence_after_change IS 'Create the adherence record based on new day of week mask.';

CREATE TRIGGER trg_after_insert_update_create_adherence
AFTER INSERT OR UPDATE ON "SIGMAmed"."PrescribedMedicationSchedule"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".fn_create_adherence_after_change();


-- FUNCTION: Delete the related record in prescribed medication schedule table and medication adherence record table
CREATE OR REPLACE FUNCTION "SIGMAmed".fn_rebuild_schedule_on_mask_change()
RETURNS TRIGGER AS $$
DECLARE
    interval_value INTERVAL;
    times_per_day INT;
    i INT;
    base_time TIME := TIME '08:00:00';
    next_time TIME;
BEGIN
    IF NEW."DefaultDayMask" IS DISTINCT FROM OLD."DefaultDayMask" THEN

        -- 1. Delete adherence records (they reference schedule IDs)
        DELETE FROM "SIGMAmed"."MedicationAdherenceRecord"
        WHERE "PrescribedMedicationScheduleId" IN (
            SELECT "PrescribedMedicationScheduleId"
            FROM "SIGMAmed"."PrescribedMedicationSchedule"
            WHERE "PrescribedMedicationId" = NEW."PrescribedMedicationId"
        );

        -- 2. Delete schedule records
        DELETE FROM "SIGMAmed"."PrescribedMedicationSchedule"
        WHERE "PrescribedMedicationId" = NEW."PrescribedMedicationId";
        
        interval_value := NEW."DoseInterval";
        times_per_day := NEW."TimesPerDay";
        -- Recreate prescribedmedicationschedule 
        next_time := base_time;
        FOR i IN 1..times_per_day LOOP
            INSERT INTO "SIGMAmed"."PrescribedMedicationSchedule"(
                "PrescribedMedicationId",
                "ReminderTime",
                "DayOfWeekMask",
                "DoseSequenceId"
            )
            VALUES(
                NEW."PrescribedMedicationId",
                next_time,
                NEW."DefaultDayMask",
                i
            );
            next_time := (next_time + interval_value);
        END LOOP;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION "SIGMAmed".fn_rebuild_schedule_on_mask_change IS 'Delete the related record in prescribed medication schedule table and medication adherence record table.';

CREATE TRIGGER trg_after_mask_update
AFTER UPDATE OF "DefaultDayMask"
ON "SIGMAmed"."PrescribedMedication"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".fn_rebuild_schedule_on_mask_change();

-- FUNCTION: Create record inside appointment reminder table 
CREATE OR REPLACE FUNCTION "SIGMAmed".fn_generate_appointment_reminders()
RETURNS TRIGGER AS $$
BEGIN
    -- Insert reminder 1 day before
    INSERT INTO "SIGMAmed"."AppointmentReminder"(
        "AppointmentId",
        "ScheduledTime"
    ) VALUES (
        NEW."AppointmentId",
        NEW."AppointmentDate" - INTERVAL '1 day'
    );

    -- Insert reminder 1 hour before
    INSERT INTO "SIGMAmed"."AppointmentReminder"(
        "AppointmentId",
        "ScheduledTime"
    ) VALUES (
        NEW."AppointmentId",
        NEW."AppointmentDate" - INTERVAL '1 hour'
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION "SIGMAmed".fn_generate_appointment_reminders IS 'Create record inside appointment reminder table.';

CREATE TRIGGER trg_after_appointment_insert
AFTER INSERT ON "SIGMAmed"."Appointment"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".fn_generate_appointment_reminders();


-- FUNCTION: Send listener to channel for newly insert patient report record
CREATE OR REPLACE FUNCTION "SIGMAmed".notify_new_patient_report()
RETURNS TRIGGER AS $$
BEGIN
    -- Only notify if VoiceDirectory is NOT NULL and keyword IS NULL
    IF NEW."VoiceDirectory" IS NOT NULL AND (NEW."Description" IS NULL OR NEW."Description" = '') AND NEW."Keywords" IS NULL THEN
        PERFORM pg_notify(
            'new_patient_report', 
            json_build_object(
                'voice_path', NEW."VoiceDirectory",
                'report_id', NEW."PatientReportId"
            )::text
        );
    ELSIF NEW."Description" IS NOT NULL AND NEW."Keywords" IS NULL THEN
        PERFORM pg_notify('new_desc_patient_report',NEW."PatientReportId"::text);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION "SIGMAmed".notify_new_patient_report IS 'Send listener to channel for newly insert patient report record.';

-- Attach trigger to PatientReport table after insert
CREATE TRIGGER patient_report_insert_trigger
AFTER INSERT ON "SIGMAmed"."PatientReport"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".notify_new_patient_report();

-- FUNCTION: Automatically sets the "UpdatedAt" column to the current timestamp on update
CREATE OR REPLACE FUNCTION public.set_updated_at_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    -- Check if UpdatedAt column exists in the table structure before setting
    IF EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_schema = TG_TABLE_SCHEMA
        AND table_name = TG_TABLE_NAME
        AND column_name = 'UpdatedAt'
    ) THEN
        NEW."UpdatedAt" = NOW();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION public.set_updated_at_timestamp() IS 'Automatically sets the "UpdatedAt" column to the current timestamp on update.';

CREATE TRIGGER set_updated_at_ClinicalInstitution
BEFORE UPDATE ON "SIGMAmed"."ClinicalInstitution"
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER set_updated_at_Medication
BEFORE UPDATE ON "SIGMAmed"."Medication"
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER set_updated_at_User
BEFORE UPDATE ON "SIGMAmed"."User"
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER set_updated_at_MedicalHistory
BEFORE UPDATE ON "SIGMAmed"."MedicalHistory"
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER set_updated_at_PatientSymptom
BEFORE UPDATE ON "SIGMAmed"."PatientSymptom"
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER set_updated_at_PatientCareTeam
BEFORE UPDATE ON "SIGMAmed"."PatientCareTeam"
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER set_updated_at_Prescription
BEFORE UPDATE ON "SIGMAmed"."Prescription"
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER set_updated_at_PrescribedMedication
BEFORE UPDATE ON "SIGMAmed"."PrescribedMedication"
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER set_updated_at_PatientSideEffect
BEFORE UPDATE ON "SIGMAmed"."PatientSideEffect"
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER set_updated_at_PrescribedMedicationSchedule
BEFORE UPDATE ON "SIGMAmed"."PrescribedMedicationSchedule"
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER set_updated_at_PatientReport
BEFORE UPDATE ON "SIGMAmed"."PatientReport"
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER set_updated_at_Appointment
BEFORE UPDATE ON "SIGMAmed"."Appointment"
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at_timestamp();

-- FUNCTION: Capture the User id and record id to insert inside the audit log table
CREATE OR REPLACE FUNCTION "SIGMAmed".audit_log_capture_function()
RETURNS TRIGGER AS $$
DECLARE
    v_old_data JSONB;
    v_new_data JSONB;
    v_record_id UUID;
	v_action_status "SIGMAmed".action_type_enum;
    
    -- The fallback ID must exist in the "SIGMAmed"."User" table (e.g., the 'system_audit' user).
    SYSTEM_FALLBACK_ID CONSTANT UUID := '00000000-0000-0000-0000-000000000000';
    
    -- Variable to hold the final ActedBy ID
    v_acted_by UUID; 
BEGIN
    -- 1. Get the ActedBy User ID
    -- Safely read the 'app.current_user_id' session variable (set by the application). 
    -- If the session variable is not set (TRUE prevents error) or is an empty string, 
    -- COALESCE falls back to the defined SYSTEM_FALLBACK_ID.
    v_acted_by := COALESCE(
        NULLIF(current_setting('app.current_user_id', TRUE), '')::UUID,
        SYSTEM_FALLBACK_ID
    );
    
    -- 2. Determine old/new data and find the RecordId based on the operation
    IF (TG_OP = 'DELETE') THEN
    -- ... (rest of the logic remains the same) ...
        v_action_status := 'delete';
        v_old_data = to_jsonb(OLD);
        v_new_data = '[]'::jsonb;
        
    ELSIF (TG_OP = 'INSERT') THEN
        v_action_status := 'insert';
        v_old_data = '[]'::jsonb;
        v_new_data = to_jsonb(NEW);
        
    ELSIF (TG_OP = 'UPDATE') THEN
        v_action_status := 'update';
        v_old_data = to_jsonb(OLD);
        v_new_data = to_jsonb(NEW);
        
    ELSE
        RETURN NULL; 
    END IF;

    -- 3. Dynamically extract the Primary Key (RecordId)
    v_record_id = COALESCE(
        v_new_data ->> (REPLACE(TG_TABLE_NAME, 'Id', '') || 'Id'), -- Tries to find 'TableNameId'
        v_new_data ->> 'UserId', -- Tries to find 'UserId'
        v_old_data ->> (REPLACE(TG_TABLE_NAME, 'Id', '') || 'Id'),
        v_old_data ->> 'UserId'
    )::UUID;

    -- 4. Insert the audit record into the AuditLog table
    INSERT INTO "SIGMAmed"."AuditLog" ("ActedBy", "TableName", "RecordId", "ActionStatus", "OldValue", "NewValue")
    VALUES (
        v_acted_by, 
        TG_TABLE_NAME, 
        v_record_id, 
        v_action_status, 
        v_old_data, 
        v_new_data
    );

    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
COMMENT ON FUNCTION "SIGMAmed".audit_log_capture_function() IS 'Capture the User id and record id to insert inside the audit log table.';

-- Table 1: ClinicalInstitution (CI)
CREATE TRIGGER audit_ci_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."ClinicalInstitution"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();

-- Table 2: Medication (Med)
CREATE TRIGGER audit_med_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."Medication"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();

-- Table 3: User (Usr)
CREATE TRIGGER audit_usr_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."User"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();

-- Table 5: Admin (Adm)
CREATE TRIGGER audit_adm_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."Admin"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();

-- Table 6: Doctor (Doc)
CREATE TRIGGER audit_doc_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."Doctor"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();

-- Table 7: Patient (Pnt)
CREATE TRIGGER audit_pnt_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."Patient"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();

-- Table 8: Medical History (MH)
CREATE TRIGGER audit_mh_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."MedicalHistory"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();

-- Table 9: Patient Symptom (PSym)
CREATE TRIGGER audit_psym_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."PatientSymptom"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();

-- Table 10: Patient Care Team (PCT)
CREATE TRIGGER audit_pct_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."PatientCareTeam"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();

-- Table 11: Prescription (Presc)
CREATE TRIGGER audit_presc_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."Prescription"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();

-- Table 12: Prescribed Medication (PMed)
CREATE TRIGGER audit_pmed_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."PrescribedMedication"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();

-- Table 13: Patient Side Effect (PSE)
CREATE TRIGGER audit_pse_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."PatientSideEffect"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();

-- Table 14: Prescribed Medication Schedule (PMS)
CREATE TRIGGER audit_pms_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."PrescribedMedicationSchedule"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();

-- Table 15: Medication Adherence Record (MAR)
CREATE TRIGGER audit_mar_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."MedicationAdherenceRecord"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();

-- Table 16: Patient Report (PR)
CREATE TRIGGER audit_pr_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."PatientReport"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();

-- Table 17: Appointment (Appt)
CREATE TRIGGER audit_appt_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."Appointment"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();

-- Table 18: Appointment Reminder (AR)
CREATE TRIGGER audit_ar_all
AFTER INSERT OR UPDATE OR DELETE ON "SIGMAmed"."AppointmentReminder"
FOR EACH ROW EXECUTE FUNCTION "SIGMAmed".audit_log_capture_function();