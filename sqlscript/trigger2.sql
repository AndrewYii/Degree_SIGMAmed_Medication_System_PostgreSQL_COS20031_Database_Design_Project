-- FUNCTION: Auto-create role-specific entry when User is inserted
CREATE OR REPLACE FUNCTION "SIGMAmed".auto_create_role_entry()
RETURNS TRIGGER AS $$
BEGIN
    -- Create corresponding role table entry based on user role
    IF NEW."Role" = 'doctor' THEN
        -- Insert placeholder doctor record (will need to be updated later)
        INSERT INTO "SIGMAmed"."Doctor" (
            "UserId",
            "MedicalLicenseNumber",
            "Specialization",
            "YearOfExperience"
        ) VALUES (
            NEW."UserId",
            'TEMP-' || NEW."UserId",  -- Temporary license number
            'General Practice',        -- Default specialization
            0                    -- Default experience
        );
        
        RAISE NOTICE 'Doctor record created for User %. Please update MedicalLicenseNumber, Specialization, and other details.', NEW."UserId";
        
    ELSIF NEW."Role" = 'patient' THEN
        -- PatientNumber will be auto-generated by trigger_generate_patient_number
        -- Leave PatientNumber empty/null, the BEFORE INSERT trigger on Patient will set it
        INSERT INTO "SIGMAmed"."Patient" (
            "UserId",
            "PatientNumber",
            "BloodType",
            "HeightCm",
            "WeightKg",
            "EmergencyContactName",
            "EmergencyContactNumber",
            "MedicationAllergies"
        ) VALUES (
            NEW."UserId",
            '',  -- Will be set by trigger_generate_patient_number
            NULL,
            0,
            0,
            ' ',
            ' ',
            '[]'::JSONB
        );
        
        RAISE NOTICE 'Patient record created for User %. Patient number will be auto-generated.', NEW."UserId";
        
    ELSIF NEW."Role" = 'admin' THEN
        INSERT INTO "SIGMAmed"."Admin" (
            "UserId",
            "AdminLevel"
        ) VALUES (
            NEW."UserId",
            'hospital'  -- Default to hospital admin level
        );
        
        RAISE NOTICE 'Admin record created for User % with hospital level access.', NEW."UserId";
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION "SIGMAmed".auto_create_role_entry IS 'Automatically create Doctor/Patient/Admin entry when User is created';

-- TRIGGER: Auto-create role entry after user insertion
CREATE TRIGGER trigger_auto_create_role_entry
AFTER INSERT ON "SIGMAmed"."User"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".auto_create_role_entry();

-- TRIGGER: Auto-generate Patient Number
CREATE OR REPLACE FUNCTION "SIGMAmed".generate_patient_number()
RETURNS TRIGGER AS $$
DECLARE
    v_year TEXT;
    v_patient_number TEXT;
    v_counter INT;
BEGIN
    -- Generate patient number if it's NULL or empty string
    IF NEW."PatientNumber" IS NULL OR NEW."PatientNumber" = '' THEN
        v_year := TO_CHAR(CURRENT_DATE, 'YYYY');
        
        -- Get next sequence using pg_advisory_xact_lock for thread safety during bulk inserts
        PERFORM pg_advisory_xact_lock(hashtext('patient_number_seq_' || v_year));
        
        -- Get the maximum sequence number for this year
        SELECT COALESCE(MAX(
            CAST(SUBSTRING("PatientNumber" FROM 10 FOR 6) AS INT)
        ), 0) + 1
        INTO v_counter
        FROM "SIGMAmed"."Patient"
        WHERE "PatientNumber" ~ ('^PAT-' || v_year || '-[0-9]{6}$');
        
        v_patient_number := 'PAT-' || v_year || '-' || LPAD(v_counter::TEXT, 6, '0');
        NEW."PatientNumber" := v_patient_number;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- TRIGGER: Auto-generate Patient Number
CREATE TRIGGER trigger_generate_patient_number
BEFORE INSERT ON "SIGMAmed"."Patient"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".generate_patient_number();

-- TRIGGER: Prevent deleting active prescriptions
CREATE OR REPLACE FUNCTION "SIGMAmed".prevent_delete_active_prescription()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD."Status" = 'active' AND NEW."IsDeleted" = TRUE THEN
        RAISE EXCEPTION 'Cannot delete active prescription. Please complete or cancel first.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- TRIGGER: Prevent deleting active prescriptions
CREATE TRIGGER trigger_prevent_delete_active_prescription
BEFORE UPDATE OF "IsDeleted" ON "SIGMAmed"."Prescription"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".prevent_delete_active_prescription();

-- TRIGGER: Prevent past appointment creation (less the create trigger)
CREATE OR REPLACE FUNCTION "SIGMAmed".prevent_past_appointments()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW."AppointmentDate" < CURRENT_DATE THEN
        RAISE EXCEPTION 'Cannot create appointment in the past';
    END IF;
    
    IF NEW."AppointmentDate" = CURRENT_DATE AND NEW."AppointmentTime" < CURRENT_TIME THEN
        RAISE EXCEPTION 'Cannot create appointment in the past';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- TRIGGER: Prevent past appointments
CREATE TRIGGER trigger_prevent_past_appointments
BEFORE INSERT ON "SIGMAmed"."Appointment"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".prevent_past_appointments();

-- TRIGGER: Notify doctor when new patient reports comes in
CREATE OR REPLACE FUNCTION "SIGMAmed".notify_new_report()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW."ReviewTime" IS NULL THEN
        PERFORM pg_notify('new_patient_report',NEW."PatientReportID"::text);
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_notify_new_report
AFTER INSERT ON "SIGMAmed"."PatientReport"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".notify_new_report();

-- TRIGGER: Notify after doctor review
CREATE OR REPLACE FUNCTION "SIGMAmed".notify_review_report()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD."ReviewTime" IS NULL AND NEW."ReviewTime" IS NOT NULL THEN
        PERFORM pg_notify('report_ready_for_processing',NEW."PatientReportID"::text);
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_notify_type_updated
AFTER UPDATE ON "SIGMAmed"."PatientReport"
FOR EACH ROW
WHEN (NEW."ReviewTime" IS NOT NULL)
EXECUTE FUNCTION "SIGMAmed".notify_review_report();

-- TRIGGER: Auto create the prescribed medication schedule record in Prescribed Medication schedule
CREATE OR REPLACE FUNCTION "SIGMAmed".fn_generate_medication_schedule()
RETURNS TRIGGER AS $$
DECLARE
    interval_value INTERVAL;
    times_per_day INT;
    i INT;
    base_time TIME := TIME '08:00:00';
    next_time TIME;
BEGIN
    interval_value := NEW."DoseInterval";
    times_per_day := NEW."TimesPerDay";

    next_time := base_time;
    FOR i IN 1..times_per_day LOOP
        INSERT INTO "SIGMAmed"."PrescribedMedicationSchedule"(
            "PrescribedMedicationId",
            "ReminderTime",
            "DayOfWeekMask",
            "DoseSequenceId"
        )
        VALUES(
            NEW."PrescribedMedicationId",
            next_time,
            NEW."DefaultDayMask",
            i
        );
        next_time := (next_time + interval_value);
    END LOOP;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_after_prescribed_med_insert
AFTER INSERT ON "SIGMAmed"."PrescribedMedication"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".fn_generate_medication_schedule();

-- TRIGGER: Auto create the adherence record in Medication adherence 
CREATE OR REPLACE FUNCTION "SIGMAmed".fn_create_adherence_record()
RETURNS TRIGGER AS $$
DECLARE 
    prescribed_date DATE;
    expiry_date DATE;
    mask TEXT;
    day_index INT;
    check_date DATE;
    scheduled_timestamp TIMESTAMPTZ;
    v_prescription_id UUID;
BEGIN 
    -- Get prescribed_date + day mask + prescription id from PrescribedMedication
    SELECT 
        "PrescribedDate",
        "DefaultDayMask",
        "PrescriptionId"
    INTO 
        prescribed_date,
        mask,
        v_prescription_id
    FROM "SIGMAmed"."PrescribedMedication"
    WHERE "PrescribedMedicationId" = NEW."PrescribedMedicationId";

    -- Get expiry date from Prescription table
    SELECT "ExpiryDate"
    INTO expiry_date
    FROM "SIGMAmed"."Prescription"
    WHERE "PrescriptionId" = v_prescription_id;

    check_date := prescribed_date;

    -- DAILY LOOP UNTIL EXPIRY DATE
    WHILE check_date <= expiry_date LOOP
        
        day_index := EXTRACT(DOW FROM check_date)::INT;
        IF day_index = 0 THEN
            day_index := 7;
        END IF;

        -- If mask = '1' for this day, insert adherence record
        IF SUBSTRING(mask FROM day_index FOR 1) = '1' THEN
            scheduled_timestamp := check_date + NEW."ReminderTime";
            
            IF scheduled_timestamp > CURRENT_TIMESTAMP THEN
            INSERT INTO "SIGMAmed"."MedicationAdherenceRecord"(
                "PrescribedMedicationScheduleID",
                "DoseQuantity",
                "ScheduledTime"
            )
            VALUES(
                NEW."PrescribedMedicationScheduleId",
                NULL,
                scheduled_timestamp
            );
            END IF;
        END IF;

        check_date := check_date + INTERVAL '1 day';
    END LOOP;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trg_after_insert_schedule
AFTER INSERT ON "SIGMAmed"."PrescribedMedicationSchedule"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".fn_create_adherence_record();


-- TRIGGER: Delete all old adherence
CREATE OR REPLACE FUNCTION "SIGMAmed".fn_delete_old_adherence()
RETURNS TRIGGER AS $$
BEGIN
    DELETE FROM "SIGMAmed"."MedicationAdherenceRecord"
    WHERE "PrescribedMedicationScheduleID" = OLD."PrescribedMedicationScheduleId" AND "CurrentStatus" = 'Pending' AND "ScheduledTime" > NOW();

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_before_update_delete_adherence
BEFORE UPDATE ON "SIGMAmed"."PrescribedMedicationSchedule"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".fn_delete_old_adherence();

-- TRIGGER: Create the adherence record based on new day of week mask
CREATE OR REPLACE FUNCTION "SIGMAmed".fn_create_adherence_after_change()
RETURNS TRIGGER AS $$
DECLARE
    prescribed_date DATE;
    expiry_date DATE;
    day_index INT;
    check_date DATE;
    scheduled_timestamp TIMESTAMPTZ;
    prescription_id UUID;
    mask TEXT;
BEGIN
    -- Get schedule mask
    mask := NEW."DayOfWeekMask";

    -- Get prescription data
    SELECT 
        "PrescribedDate",
        "PrescriptionId"
    INTO
        prescribed_date,
        prescription_id
    FROM "SIGMAmed"."PrescribedMedication"
    WHERE "PrescribedMedicationId" = NEW."PrescribedMedicationId";

    -- Get expiry date
    SELECT "ExpiryDate"
    INTO expiry_date
    FROM "SIGMAmed"."Prescription"
    WHERE "PrescriptionId" = prescription_id;

    check_date := prescribed_date;

    -- Recreate adherence records
    WHILE check_date <= expiry_date LOOP
        day_index := EXTRACT(DOW FROM check_date);

        IF day_index = 0 THEN
            day_index := 7;
        END IF;

        IF SUBSTRING(mask FROM day_index FOR 1) = '1' THEN
            scheduled_timestamp := check_date + NEW."ReminderTime";

            INSERT INTO "SIGMAmed"."MedicationAdherenceRecord"(
                "PrescribedMedicationScheduleID",
                "DoseQuantity",
                "ScheduledTime"
            ) VALUES (
                NEW."PrescribedMedicationScheduleId",
                NULL,
                scheduled_timestamp
            );
        END IF;

        check_date := check_date + INTERVAL '1 day';
    END LOOP;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_after_insert_update_create_adherence
AFTER INSERT OR UPDATE ON "SIGMAmed"."PrescribedMedicationSchedule"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".fn_create_adherence_after_change();


-- TRIGGER: Delete the related record in prescribed medication schedule table and medication adherence record table
CREATE OR REPLACE FUNCTION "SIGMAmed".fn_rebuild_schedule_on_mask_change()
RETURNS TRIGGER AS $$
DECLARE
    interval_value INTERVAL;
    times_per_day INT;
    i INT;
    base_time TIME := TIME '08:00:00';
    next_time TIME;
BEGIN
    IF NEW."DefaultDayMask" IS DISTINCT FROM OLD."DefaultDayMask" THEN

        -- 1. Delete adherence records (they reference schedule IDs)
        DELETE FROM "SIGMAmed"."MedicationAdherenceRecord"
        WHERE "PrescribedMedicationScheduleID" IN (
            SELECT "PrescribedMedicationScheduleId"
            FROM "SIGMAmed"."PrescribedMedicationSchedule"
            WHERE "PrescribedMedicationId" = NEW."PrescribedMedicationId"
        );

        -- 2. Delete schedule records
        DELETE FROM "SIGMAmed"."PrescribedMedicationSchedule"
        WHERE "PrescribedMedicationId" = NEW."PrescribedMedicationId";
        
        interval_value := NEW."DoseInterval";
        times_per_day := NEW."TimesPerDay";
        -- Recreate prescribedmedicationschedule 
        next_time := base_time;
        FOR i IN 1..times_per_day LOOP
            INSERT INTO "SIGMAmed"."PrescribedMedicationSchedule"(
                "PrescribedMedicationId",
                "ReminderTime",
                "DayOfWeekMask",
                "DoseSequenceId"
            )
            VALUES(
                NEW."PrescribedMedicationId",
                next_time,
                NEW."DefaultDayMask",
                i
            );
            next_time := (next_time + interval_value);
        END LOOP;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_after_mask_update
AFTER UPDATE OF "DefaultDayMask"
ON "SIGMAmed"."PrescribedMedication"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".fn_rebuild_schedule_on_mask_change();

-- TRIGGER: Create record inside appointment reminder table 
CREATE OR REPLACE FUNCTION "SIGMAmed".fn_generate_appointment_reminders()
RETURNS TRIGGER AS $$
BEGIN
    -- Insert reminder 1 day before
    INSERT INTO "SIGMAmed"."AppointmentReminder"(
        "AppointmentID",
        "ScheduledTime"
    ) VALUES (
        NEW."AppointmentId",
        NEW."AppointmentDate" - INTERVAL '1 day'
    );

    -- Insert reminder 1 hour before
    INSERT INTO "SIGMAmed"."AppointmentReminder"(
        "AppointmentID",
        "ScheduledTime"
    ) VALUES (
        NEW."AppointmentId",
        NEW."AppointmentDate" - INTERVAL '1 hour'
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_after_appointment_insert
AFTER INSERT ON "SIGMAmed"."Appointment"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".fn_generate_appointment_reminders();


