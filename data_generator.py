import random
from datetime import datetime, timedelta, time, date
from faker import Faker
import json

fake = Faker()
Faker.seed(42)
random.seed(42)

class SIGMAmedDataGenerator:    
    # Medical data constants
    SPECIALIZATIONS = [
        'Cardiology', 'Dermatology', 'Endocrinology', 'Gastroenterology',
        'Hematology', 'Neurology', 'Oncology', 'Orthopedics',
        'Pediatrics', 'Psychiatry', 'Radiology', 'General Practice'
    ]
    
    BLOOD_TYPES = ['A+', 'A-', 'B+', 'B-', 'AB+', 'AB-', 'O+', 'O-']
    
    MEDICATIONS = [
        'Amoxicillin', 'Metformin', 'Lisinopril', 'Atorvastatin',
        'Levothyroxine', 'Omeprazole', 'Amlodipine', 'Simvastatin',
        'Losartan', 'Gabapentin', 'Hydrochlorothiazide', 'Metoprolol',
        'Albuterol', 'Ibuprofen', 'Acetaminophen', 'Aspirin',
        'Prednisone', 'Azithromycin', 'Ciprofloxacin', 'Pantoprazole'
    ]
    
    DISEASES = [
        'Hypertension', 'Type 2 Diabetes', 'Asthma', 'Arthritis',
        'Depression', 'Anxiety', 'Migraine', 'GERD',
        'High Cholesterol', 'Hypothyroidism', 'Osteoporosis', 'COPD'
    ]
    
    SYMPTOMS = [
        'Headache', 'Fatigue', 'Dizziness', 'Nausea',
        'Chest Pain', 'Shortness of Breath', 'Joint Pain', 'Fever',
        'Cough', 'Abdominal Pain', 'Back Pain', 'Insomnia'
    ]
    
    SIDE_EFFECTS = [
        'Nausea', 'Dizziness', 'Drowsiness', 'Dry Mouth',
        'Headache', 'Constipation', 'Diarrhea', 'Fatigue',
        'Insomnia', 'Rash', 'Upset Stomach', 'Blurred Vision'
    ]
    
    ALLERGIES = [
        'Penicillin', 'Sulfa Drugs', 'Aspirin', 'Ibuprofen',
        'Codeine', 'Morphine', 'NSAIDs', 'Latex'
    ]
    
    WEEKDAYS = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
    
    def __init__(self):
        self.fake = fake
    
    def generate_clinical_institution(self, count=1):
        institutions = []
        for i in range(count):
            name = f"{fake.city()} {random.choice(['General Hospital', 'Medical Center', 'Health Clinic', 'Community Hospital'])}"
            institutions.append({
                'ClinicalInstitutionName': name,
                'Description': f"A leading healthcare facility providing comprehensive medical services in {fake.city()}.",
                'IsDeleted': False
            })
        return institutions
    
    def generate_user(self, institution_id, role='patient', count=1):
        users = []
        for i in range(count):
            first_name = fake.first_name()
            last_name = fake.last_name()
            # Add timestamp and larger random number for uniqueness in bulk operations
            username = f"{first_name.lower()}.{last_name.lower()}{random.randint(1, 999999)}"
            
            users.append({
                'ClinicalInstitutionId': institution_id,
                'Username': username,
                'Email': f"{username}@{fake.domain_name()}",
                'PasswordHash': '$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewY5GyYILSBfz.3O',  # 'password123'
                'Role': role,
                'ICPassportNumber': fake.bothify(text='??########', letters='ABCDEFGHIJKLMNOPQRSTUVWXYZ'),
                'FirstName': first_name,
                'LastName': last_name,
                'Phone': fake.phone_number()[:20],
                'DateOfBirth': fake.date_of_birth(minimum_age=18, maximum_age=90),
                'FcmKey': None,
                'ProfilePictureUrl': None,
                'IsActive': True,
                'IsDeleted': False
            })
        return users
    
    def generate_doctor(self, user_id):
        return {
            'UserId': user_id,
            'MedicalLicenseNumber': f"MD-{fake.bothify(text='####-####', letters='0123456789')}",
            'Specialization': random.choice(self.SPECIALIZATIONS),
            'YearOfExperience': random.randint(1, 35),
            'MedicalSchool': f"{fake.city()} Medical School",
            'Bio': fake.text(max_nb_chars=200)
        }
    
    def generate_patient(self, user_id):
        # Generate random medication allergies (0-3 allergies)
        num_allergies = random.randint(0, 3)
        allergies = random.sample(self.ALLERGIES, min(num_allergies, len(self.ALLERGIES)))
        
        return {
            'UserId': user_id,
            'PatientNumber': '',  # Will be auto-generated by trigger
            'BloodType': random.choice(self.BLOOD_TYPES) if random.random() > 0.1 else None,
            'HeightCm': round(random.uniform(150.0, 200.0), 2) if random.random() > 0.2 else None,
            'WeightKg': round(random.uniform(45.0, 120.0), 2) if random.random() > 0.2 else None,
            'EmergencyContactName': fake.name() if random.random() > 0.1 else None,
            'EmergencyContactNumber': fake.phone_number()[:20] if random.random() > 0.1 else None,
            'MedicationAllergies': json.dumps(allergies)
        }
    
    def generate_admin(self, user_id):
        return {
            'UserId': user_id,
            'AdminLevel': random.choice(['super', 'hospital'])
        }
    
    def generate_medication(self, institution_id, count=None):
        # If count not specified, use all medications
        meds_to_use = random.sample(self.MEDICATIONS, count) if count else self.MEDICATIONS
        
        medications = []
        for med_name in meds_to_use:
            medications.append({
                'ClinicalInstitutionID': institution_id,
                'MedicationName': med_name,
                'TotalAmount': random.randint(50, 500),
                'IsDeleted': False
            })
        return medications
    
    def generate_assigned_doctor(self, doctor_id, patient_id, level='primary'):
        return {
            'DoctorId': doctor_id,
            'PatientId': patient_id,
            'DoctorLevel': level,
            'IsDeleted': False
        }
    
    def generate_medical_history(self, patient_id, count=None):
        # Generate 0-3 medical history entries if count not specified
        num_entries = count if count is not None else random.randint(0, 3)
        
        histories = []
        diseases_used = random.sample(self.DISEASES, min(num_entries, len(self.DISEASES)))
        
        for disease in diseases_used:
            histories.append({
                'PatientId': patient_id,
                'DiseaseName': disease,
                'Severity': random.randint(1, 10),
                'IsDeleted': False
            })
        return histories
    
    def generate_patient_symptom(self, medical_history_id, count=None):
        num_symptoms = count if count is not None else random.randint(1, 4)
        
        symptoms = []
        symptoms_used = random.sample(self.SYMPTOMS, min(num_symptoms, len(self.SYMPTOMS)))
        
        for symptom in symptoms_used:
            symptoms.append({
                'MedicalHistoryId': medical_history_id,
                'SymptomName': symptom
            })
        return symptoms
    
    def generate_prescription(self, doctor_id, patient_id, prescribed_date=None):
        if prescribed_date is None:
            prescribed_date = fake.date_between(start_date='-1y', end_date='today')
        
        return {
            'DoctorId': doctor_id,
            'PatientId': patient_id,
            'PrescriptionNumber': '',  # Will be auto-generated by trigger
            'Status': random.choice(['active', 'completed']),
            'PrescribedDate': prescribed_date,
            'IsDeleted': False
        }
    
    def generate_prescribed_medication(self, prescription_id, medication_id, start_date=None):
        if start_date is None:
            start_date = fake.date_between(start_date='-6m', end_date='today')
        
        duration_days = random.randint(7, 90)
        end_date = start_date + timedelta(days=duration_days)
        
        dosage_instructions = random.choice([
            'Take one tablet daily with food',
            'Take two tablets twice daily',
            'Take one capsule every 8 hours',
            'Take as needed for pain',
            'Apply topically twice daily',
            'Take one tablet at bedtime'
        ])
        
        return {
            'PrescriptionId': prescription_id,
            'MedicationId': medication_id,
            'StartDate': start_date,
            'EndDate': end_date,
            'DosageInstruction': dosage_instructions,
            'IsDeleted': False
        }
    
    def generate_prescribed_medication_schedule(self, prescribed_medication_id, count=None):
        num_schedules = count if count is not None else random.randint(1, 3)
        
        schedules = []
        weekdays_used = random.sample(self.WEEKDAYS, min(num_schedules, len(self.WEEKDAYS)))
        
        for weekday in weekdays_used:
            meal_time = time(
                hour=random.choice([8, 12, 18, 21]),
                minute=random.choice([0, 15, 30, 45])
            )
            
            schedules.append({
                'PrescribedMedicationId': prescribed_medication_id,
                'Weekday': weekday,
                'MealTiming': meal_time,
                'Dose': random.randint(1, 3)
            })
        return schedules
    
    def generate_reminder(self, medication_schedule_id):
        return {
            'MedicationScheduleID': medication_schedule_id,
            'IsActive': random.choice([True, True, True, False]),  # 75% active
            'CurrentStatus': random.choice(['ignored', 'completed']),
            'RemindGap': time(hour=0, minute=random.choice([5, 10, 15, 30]))
        }
    
    def generate_appointment(self, doctor_id, patient_id, appointment_date=None):
        if appointment_date is None:
            # Generate appointments only in the future (1 to 60 days ahead)
            days_offset = random.randint(1, 60)
            appointment_date = date.today() + timedelta(days=days_offset)
        
        # Ensure appointment is not in the past
        if appointment_date < date.today():
            appointment_date = date.today() + timedelta(days=random.randint(1, 30))
        
        # For today's appointments, ensure time is in the future
        current_time = datetime.now().time()
        if appointment_date == date.today():
            # Set appointment at least 1 hour from now
            future_hour = (datetime.now() + timedelta(hours=1)).hour
            if future_hour >= 17:  # If too late, schedule for tomorrow
                appointment_date = date.today() + timedelta(days=1)
                appointment_time = time(hour=random.randint(9, 16), minute=random.choice([0, 15, 30, 45]))
            else:
                appointment_time = time(hour=random.randint(future_hour, 16), minute=random.choice([0, 15, 30, 45]))
        else:
            appointment_time = time(
                hour=random.randint(9, 16),
                minute=random.choice([0, 15, 30, 45])
            )
        
        # Future appointments should be scheduled or confirmed
        status = random.choice(['scheduled', 'confirmed'])
        
        return {
            'DoctorId': doctor_id,
            'PatientId': patient_id,
            'AppointmentDate': appointment_date,
            'AppointmentTime': appointment_time,
            'DurationMinutes': random.choice([15, 30, 45, 60]),
            'AppointmentType': random.choice(['consultation', 'follow-up']),
            'Status': status,
            'Notes': fake.sentence() if random.random() > 0.5 else None,
            'IsEmergency': random.random() < 0.1,  # 10% emergency
            'IsDeleted': False
        }
    
    def generate_patient_side_effect(self, prescribed_medication_id):
        onset_date = fake.date_between(start_date='-3m', end_date='today')
        has_resolved = random.random() > 0.3
        resolution_date = fake.date_between(start_date=onset_date, end_date='today') if has_resolved else None
        
        return {
            'PrescribedMedicationID': prescribed_medication_id,
            'SideEffectName': random.choice(self.SIDE_EFFECTS),
            'Severity': random.randint(1, 10),
            'OnsetDate': onset_date,
            'PatientNotes': fake.sentence() if random.random() > 0.5 else None,
            'ResolutionDate': resolution_date
        }
    
    def generate_patient_report(self, doctor_id, patient_id):
        return {
            'DoctorId': doctor_id,
            'PatientId': patient_id,
            'Status': random.choice(['Appointment', 'SideEffect', 'Symptom', 'No']),
            'Reason': fake.sentence() if random.random() > 0.3 else None,
            'AttachmentDirectory': None,
            'IsDeleted': False
        }
