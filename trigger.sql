-- Set search path for current session
SET search_path TO "SIGMAmed", public;

-- FUNCTION: Auto-update UpdatedAt timestamp
CREATE OR REPLACE FUNCTION "SIGMAmed".update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW."UpdatedAt" = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- TRIGGER: Auto-update ClinicalInstitution UpdatedAt
CREATE TRIGGER trigger_update_clinical_institution_timestamp
BEFORE UPDATE ON "SIGMAmed"."ClinicalInstitution"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".update_updated_at();

-- FUNCTION: Auto-create role-specific entry when User is inserted
CREATE OR REPLACE FUNCTION "SIGMAmed".auto_create_role_entry()
RETURNS TRIGGER AS $$
BEGIN
    -- Create corresponding role table entry based on user role
    IF NEW."Role" = 'doctor' THEN
        -- Insert placeholder doctor record (will need to be updated later)
        INSERT INTO "SIGMAmed"."Doctor" (
            "UserId",
            "MedicalLicenseNumber",
            "Specialization",
            "YearOfExperience",
            "MedicalSchool",
            "Bio"
        ) VALUES (
            NEW."UserId",
            'TEMP-' || NEW."UserId",  -- Temporary license number
            'General Practice',        -- Default specialization
            0,                         -- Default experience
            'To Be Updated',          -- Placeholder medical school
            NULL                       -- No bio initially
        );
        
        RAISE NOTICE 'Doctor record created for User %. Please update MedicalLicenseNumber, Specialization, and other details.', NEW."UserId";
        
    ELSIF NEW."Role" = 'patient' THEN
        -- PatientNumber will be auto-generated by trigger
        INSERT INTO "SIGMAmed"."Patient" (
            "UserId",
            "PatientNumber",
            "BloodType",
            "HeightCm",
            "WeightKg",
            "EmergencyContactName",
            "EmergencyContactNumber",
            "MedicationAllergies"
        ) VALUES (
            NEW."UserId",
            '',  -- Will be auto-generated by trigger_generate_patient_number
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            '[]'::JSONB
        );
        
        RAISE NOTICE 'Patient record created for User %. Patient number will be auto-generated.', NEW."UserId";
        
    ELSIF NEW."Role" = 'admin' THEN
        INSERT INTO "SIGMAmed"."Admin" (
            "UserId",
            "AdminLevel"
        ) VALUES (
            NEW."UserId",
            'hospital'  -- Default to hospital admin level
        );
        
        RAISE NOTICE 'Admin record created for User % with hospital level access.', NEW."UserId";
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION "SIGMAmed".auto_create_role_entry IS 'Automatically create Doctor/Patient/Admin entry when User is created';

-- TRIGGER: Auto-create role entry after user insertion
CREATE TRIGGER trigger_auto_create_role_entry
AFTER INSERT ON "SIGMAmed"."User"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".auto_create_role_entry();

-- TRIGGER: Prevent role change if would orphan role-specific data
CREATE OR REPLACE FUNCTION "SIGMAmed".prevent_invalid_role_change()
RETURNS TRIGGER AS $$
BEGIN
    -- Only check if role is actually changing
    IF OLD."Role" != NEW."Role" THEN
        -- Check if changing from doctor role
        IF OLD."Role" = 'doctor' THEN
            -- Check for existing prescriptions
            IF EXISTS (SELECT 1 FROM "SIGMAmed"."Prescription" WHERE "DoctorId" = NEW."UserId" AND "IsDeleted" = FALSE) THEN
                RAISE EXCEPTION 'Cannot change role from doctor: User has active prescriptions';
            END IF;
            
            -- Check for existing appointments
            IF EXISTS (SELECT 1 FROM "SIGMAmed"."Appointment" WHERE "DoctorId" = NEW."UserId" AND "IsDeleted" = FALSE) THEN
                RAISE EXCEPTION 'Cannot change role from doctor: User has active appointments';
            END IF;
            
            -- Check for assigned patients
            IF EXISTS (SELECT 1 FROM "SIGMAmed"."AssignedDoctor" WHERE "DoctorId" = NEW."UserId" AND "IsDeleted" = FALSE) THEN
                RAISE EXCEPTION 'Cannot change role from doctor: User has assigned patients';
            END IF;
        END IF;
        
        -- Check if changing from patient role
        IF OLD."Role" = 'patient' THEN
            -- Check for existing prescriptions
            IF EXISTS (SELECT 1 FROM "SIGMAmed"."Prescription" WHERE "PatientId" = NEW."UserId" AND "IsDeleted" = FALSE) THEN
                RAISE EXCEPTION 'Cannot change role from patient: User has active prescriptions';
            END IF;
            
            -- Check for medical history
            IF EXISTS (SELECT 1 FROM "SIGMAmed"."MedicalHistory" WHERE "PatientId" = NEW."UserId" AND "IsDeleted" = FALSE) THEN
                RAISE EXCEPTION 'Cannot change role from patient: User has medical history records';
            END IF;
            
            -- Check for appointments
            IF EXISTS (SELECT 1 FROM "SIGMAmed"."Appointment" WHERE "PatientId" = NEW."UserId" AND "IsDeleted" = FALSE) THEN
                RAISE EXCEPTION 'Cannot change role from patient: User has appointments';
            END IF;
        END IF;
        
        RAISE NOTICE 'Role change from % to % is allowed. Role-specific table entry will be updated.', OLD."Role", NEW."Role";
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION "SIGMAmed".prevent_invalid_role_change IS 'Prevent role changes that would orphan critical data';

-- TRIGGER: Validate role changes
CREATE TRIGGER trigger_prevent_invalid_role_change
BEFORE UPDATE OF "Role" ON "SIGMAmed"."User"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".prevent_invalid_role_change();

-- TRIGGER: Handle role table cleanup when role changes
CREATE OR REPLACE FUNCTION "SIGMAmed".handle_role_change()
RETURNS TRIGGER AS $$
BEGIN
    -- Only process if role actually changed
    IF OLD."Role" != NEW."Role" THEN
        -- Delete old role entry
        IF OLD."Role" = 'doctor' THEN
            DELETE FROM "SIGMAmed"."Doctor" WHERE "UserId" = NEW."UserId";
        ELSIF OLD."Role" = 'patient' THEN
            DELETE FROM "SIGMAmed"."Patient" WHERE "UserId" = NEW."UserId";
        ELSIF OLD."Role" = 'admin' THEN
            DELETE FROM "SIGMAmed"."Admin" WHERE "UserId" = NEW."UserId";
        END IF;
        
        -- Create new role entry
        IF NEW."Role" = 'doctor' THEN
            INSERT INTO "SIGMAmed"."Doctor" (
                "UserId", "MedicalLicenseNumber", "Specialization", 
                "YearOfExperience", "MedicalSchool"
            ) VALUES (
                NEW."UserId", 'TEMP-' || NEW."UserId", 'General Practice', 0, 'To Be Updated'
            );
        ELSIF NEW."Role" = 'patient' THEN
            INSERT INTO "SIGMAmed"."Patient" (
                "UserId", "PatientNumber", "MedicationAllergies"
            ) VALUES (
                NEW."UserId", '', '[]'::JSONB
            );
        ELSIF NEW."Role" = 'admin' THEN
            INSERT INTO "SIGMAmed"."Admin" (
                "UserId", "AdminLevel"
            ) VALUES (
                NEW."UserId", 'hospital'
            );
        END IF;
        
        RAISE NOTICE 'Role changed from % to % for User %', OLD."Role", NEW."Role", NEW."UserId";
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION "SIGMAmed".handle_role_change IS 'Clean up old role entry and create new one when role changes';

-- TRIGGER: Handle role changes
CREATE TRIGGER trigger_handle_role_change
AFTER UPDATE OF "Role" ON "SIGMAmed"."User"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".handle_role_change();

-- TRIGGER: Auto-generate Prescription Number
CREATE OR REPLACE FUNCTION "SIGMAmed".generate_prescription_number()
RETURNS TRIGGER AS $$
DECLARE
    v_year TEXT;
    v_month TEXT;
    v_sequence INT;
    v_prescription_number TEXT;
BEGIN
    IF NEW."PrescriptionNumber" IS NULL OR NEW."PrescriptionNumber" = '' THEN
        v_year := TO_CHAR(CURRENT_DATE, 'YYYY');
        v_month := TO_CHAR(CURRENT_DATE, 'MM');
        
        -- Get next sequence for this month
        SELECT COALESCE(MAX(
            CAST(SUBSTRING("PrescriptionNumber" FROM 10 FOR 5) AS INT)
        ), 0) + 1
        INTO v_sequence
        FROM "SIGMAmed"."Prescription"
        WHERE "PrescriptionNumber" LIKE 'RX-' || v_year || v_month || '%';
        
        v_prescription_number := 'RX-' || v_year || v_month || '-' || LPAD(v_sequence::TEXT, 5, '0');
        NEW."PrescriptionNumber" := v_prescription_number;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- TRIGGER: Auto-generate Prescription Number
CREATE TRIGGER trigger_generate_prescription_number
BEFORE INSERT ON "SIGMAmed"."Prescription"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".generate_prescription_number();

-- TRIGGER: Auto-generate Patient Number
CREATE OR REPLACE FUNCTION "SIGMAmed".generate_patient_number()
RETURNS TRIGGER AS $$
DECLARE
    v_year TEXT;
    v_sequence INT;
    v_patient_number TEXT;
BEGIN
    IF NEW."PatientNumber" IS NULL OR NEW."PatientNumber" = '' THEN
        v_year := TO_CHAR(CURRENT_DATE, 'YYYY');
        
        -- Get next sequence for this year
        SELECT COALESCE(MAX(
            CAST(SUBSTRING("PatientNumber" FROM 7 FOR 6) AS INT)
        ), 0) + 1
        INTO v_sequence
        FROM "SIGMAmed"."Patient"
        WHERE "PatientNumber" LIKE 'PAT-' || v_year || '%';
        
        v_patient_number := 'PAT-' || v_year || '-' || LPAD(v_sequence::TEXT, 6, '0');
        NEW."PatientNumber" := v_patient_number;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- TRIGGER: Auto-generate Patient Number
CREATE TRIGGER trigger_generate_patient_number
BEFORE INSERT ON "SIGMAmed"."Patient"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".generate_patient_number();

-- TRIGGER: Prevent deleting active prescriptions
CREATE OR REPLACE FUNCTION "SIGMAmed".prevent_delete_active_prescription()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD."Status" = 'active' AND NEW."IsDeleted" = TRUE THEN
        RAISE EXCEPTION 'Cannot delete active prescription. Please complete or cancel first.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- TRIGGER: Prevent deleting active prescriptions
CREATE TRIGGER trigger_prevent_delete_active_prescription
BEFORE UPDATE OF "IsDeleted" ON "SIGMAmed"."Prescription"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".prevent_delete_active_prescription();

-- FUNCTION: Auto-complete prescription when all medications end dates passed
CREATE OR REPLACE FUNCTION "SIGMAmed".auto_complete_expired_prescriptions()
RETURNS void AS $$
BEGIN
    UPDATE "SIGMAmed"."Prescription" p
    SET "Status" = 'completed'
    WHERE "Status" = 'active'
      AND "IsDeleted" = FALSE
      AND NOT EXISTS (
          SELECT 1 
          FROM "SIGMAmed"."PrescribedMedication" pm
          WHERE pm."PrescriptionId" = p."PrescriptionId"
            AND pm."EndDate" >= CURRENT_DATE
            AND pm."IsDeleted" = FALSE
      );
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION "SIGMAmed".auto_complete_expired_prescriptions IS 'Auto-complete prescriptions where all medications have ended';

-- TRIGGER: Validate appointment time conflicts
CREATE OR REPLACE FUNCTION "SIGMAmed".validate_appointment_time_conflict()
RETURNS TRIGGER AS $$
DECLARE
    v_conflict_count INT;
BEGIN
    -- Check for doctor time conflicts
    SELECT COUNT(*) INTO v_conflict_count
    FROM "SIGMAmed"."Appointment"
    WHERE "DoctorId" = NEW."DoctorId"
      AND "AppointmentDate" = NEW."AppointmentDate"
      AND "Status" IN ('scheduled', 'confirmed')
      AND "IsDeleted" = FALSE
      AND "AppointmentId" != COALESCE(NEW."AppointmentId", '00000000-0000-0000-0000-000000000000'::UUID)
      AND (
          -- Check time overlap
          (NEW."AppointmentTime", NEW."AppointmentTime" + (NEW."DurationMinutes" || ' minutes')::INTERVAL)
          OVERLAPS
          ("AppointmentTime", "AppointmentTime" + ("DurationMinutes" || ' minutes')::INTERVAL)
      );
    
    IF v_conflict_count > 0 THEN
        RAISE EXCEPTION 'Doctor has conflicting appointment at this time';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- TRIGGER: Validate appointment conflicts
CREATE TRIGGER trigger_validate_appointment_conflict
BEFORE INSERT OR UPDATE ON "SIGMAmed"."Appointment"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".validate_appointment_time_conflict();

-- TRIGGER: Check medication stock before prescribing
CREATE OR REPLACE FUNCTION "SIGMAmed".check_medication_stock()
RETURNS TRIGGER AS $$
DECLARE
    v_current_stock INT;
    v_medication_name VARCHAR(100);
BEGIN
    SELECT "TotalAmount", "MedicationName" 
    INTO v_current_stock, v_medication_name
    FROM "SIGMAmed"."Medication"
    WHERE "MedicationID" = NEW."MedicationId"
      AND "IsDeleted" = FALSE;
    
    IF v_current_stock <= 0 THEN
        RAISE WARNING 'Low stock alert: % is out of stock', v_medication_name;
    ELSIF v_current_stock <= 10 THEN
        RAISE WARNING 'Low stock alert: % has only % units remaining', v_medication_name, v_current_stock;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- TRIGGER: Check medication stock
CREATE TRIGGER trigger_check_medication_stock
BEFORE INSERT OR UPDATE ON "SIGMAmed"."PrescribedMedication"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".check_medication_stock();

-- TRIGGER: Prevent past appointment creation
CREATE OR REPLACE FUNCTION "SIGMAmed".prevent_past_appointments()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW."AppointmentDate" < CURRENT_DATE THEN
        RAISE EXCEPTION 'Cannot create appointment in the past';
    END IF;
    
    IF NEW."AppointmentDate" = CURRENT_DATE AND NEW."AppointmentTime" < CURRENT_TIME THEN
        RAISE EXCEPTION 'Cannot create appointment in the past';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- TRIGGER: Prevent past appointments
CREATE TRIGGER trigger_prevent_past_appointments
BEFORE INSERT ON "SIGMAmed"."Appointment"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".prevent_past_appointments();

-- TRIGGER: Validate prescribed medication dates
CREATE OR REPLACE FUNCTION "SIGMAmed".validate_prescribed_medication_dates()
RETURNS TRIGGER AS $$
BEGIN
    -- Ensure logical date progression
    IF NEW."StartDate" > NEW."EndDate" THEN
        RAISE EXCEPTION 'End date must be after start date';
    END IF;
    
    -- Warn if medication is very long (> 1 year)
    IF NEW."EndDate" - NEW."StartDate" > 365 THEN
        RAISE WARNING 'Prescribed medication duration exceeds one year';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- TRIGGER: Validate prescribed medication dates
CREATE TRIGGER trigger_validate_prescribed_medication_dates
BEFORE INSERT OR UPDATE ON "SIGMAmed"."PrescribedMedication"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".validate_prescribed_medication_dates();

-- TRIGGER: Auto-deactivate reminder when prescribed medication completed
CREATE OR REPLACE FUNCTION "SIGMAmed".auto_deactivate_reminder()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW."EndDate" < CURRENT_DATE AND OLD."EndDate" >= CURRENT_DATE THEN
        UPDATE "SIGMAmed"."Reminder" r
        SET "IsActive" = FALSE
        FROM "SIGMAmed"."PrescribedMedicationSchedule" pms
        WHERE r."MedicationScheduleID" = pms."PrescribedMedicationScheduleId"
          AND pms."PrescribedMedicationId" = NEW."PrescribedMedicationId";
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- TRIGGER: Auto-deactivate reminders
CREATE TRIGGER trigger_auto_deactivate_reminder
AFTER UPDATE OF "EndDate" ON "SIGMAmed"."PrescribedMedication"
FOR EACH ROW
EXECUTE FUNCTION "SIGMAmed".auto_deactivate_reminder();